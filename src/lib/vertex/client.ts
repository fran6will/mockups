import { GoogleGenerativeAI } from '@google/generative-ai';

// Initialize the Google Gen AI Client
const apiKey = process.env.GEMINI_API_KEY;

// Using Copié-Collé (Gemini 3 Pro Image)
const modelId = 'gemini-3-pro-image-preview';

/**
 * Helper to fetch and convert URL or Data URL to a Generative AI Part.
 * Supports both remote URLs (fetch) and Data URLs (base64).
 */
export const getImagePart = async (url: string) => {
    // 1. Handle Data URLs (e.g. "data:image/png;base64,...")
    if (url.startsWith('data:')) {
        const [mimeTypePart, base64] = url.split(';base64,');
        return {
            inlineData: {
                data: base64,
                mimeType: mimeTypePart.replace('data:', '')
            }
        };
    }

    // 2. Handle Remote URLs
    const response = await fetch(url);
    const arrayBuffer = await response.arrayBuffer();
    const base64 = Buffer.from(arrayBuffer).toString('base64');
    const mimeType = response.headers.get('content-type') || 'image/png';
    return {
        inlineData: {
            data: base64,
            mimeType
        }
    };
};

export const generateMockup = async (
    baseImageUrl: string,
    logoUrl: string,
    prompt: string,
    aspectRatio: string = '1:1',
    imageSize: string = '1K'
) => {
    if (!apiKey) {
        throw new Error("Missing GEMINI_API_KEY in environment variables.");
    }

    try {
        console.log(`Calling Copié-Collé (Gemini API) with Aspect Ratio: ${aspectRatio} and Size: ${imageSize}...`);

        const genAI = new GoogleGenerativeAI(apiKey);
        const model = genAI.getGenerativeModel({
            model: modelId,
            generationConfig: {
                // Gemini 3 Pro Image requires both TEXT and IMAGE modalities
                responseModalities: ["TEXT", "IMAGE"],
                imageConfig: {
                    aspectRatio: aspectRatio,
                    imageSize: imageSize
                }
            } as any
        });

        console.log("Fetching image assets...");
        const [baseImagePart, logoImagePart] = await Promise.all([
            getImagePart(baseImageUrl),
            getImagePart(logoUrl)
        ]);

        // 1. Prepare Inputs
        // The 'prompt' variable contains either the custom product instruction or a default instruction.
        const fullPrompt = `Generate a photorealistic product shot. ${prompt} Important: Keep the provided design/logo unchanged, preserving its colors, text, and details exactly as they appear. Apply it realistically to the surface. Ensure high quality, detailed texture, and realistic lighting.`;

        console.log("Sending request to model with images...");
        // 2. Call API
        // Pass the text prompt AND the image parts
        const result = await model.generateContent([
            fullPrompt,
            baseImagePart,
            logoImagePart
        ]);
        const response = await result.response;

        // 3. Extract Image
        // We'll inspect the response structure. 
        // If it's standard text generation, it returns text.
        // If it's image generation, it usually returns inlineData.

        console.log("Model response candidates:", response.candidates);

        const parts = response.candidates?.[0]?.content?.parts;
        const imagePart = parts?.find((part: any) => part.inlineData);

        if (!imagePart || !imagePart.inlineData) {
            // If no image part, maybe it returned text saying it can't do it?
            const textPart = parts?.find((part: any) => part.text);
            if (textPart) {
                console.warn("Model returned text instead of image:", textPart.text);
                throw new Error("Model returned text: " + textPart.text);
            }
            throw new Error("No image generated by the model.");
        }

        const base64Image = imagePart.inlineData.data;
        const mimeType = imagePart.inlineData.mimeType || 'image/png';

        return {
            success: true,
            mockUrl: `data:${mimeType};base64,${base64Image}`
        };

    } catch (error: any) {
        console.error("Gemini API Error:", error);
        return {
            success: false, // Let the frontend show the error
            error: error.message || "Unknown error"
        };
    }
};

export const analyzeMockupImage = async (imageUrl: string, productType: 'mockup' | 'scene' = 'mockup', productNameHint?: string, keywordsHint?: string) => {
    if (!apiKey) {
        throw new Error("Missing GEMINI_API_KEY in environment variables.");
    }

    try {
        const genAI = new GoogleGenerativeAI(apiKey);
        // Use Gemini 3 Pro Preview as requested
        const model = genAI.getGenerativeModel({ model: "gemini-3-pro-preview" });

        // Fetch image part using shared helper
        const imagePart = await getImagePart(imageUrl);

        let prompt = '';

        const hintContext = productNameHint ? `Context/Product Name: "${productNameHint}".` : '';
        const keywordContext = keywordsHint ? `Keywords to include: "${keywordsHint}".` : '';

        if (productType === 'scene') {
            prompt = `
                Analyze this background scene image and generate SEO-optimized details for it.
                ${hintContext}
                ${keywordContext}
                Return ONLY a JSON object with the following fields:
                - title: A catchy, descriptive title (e.g., "Cozy Wooden Desk Scene with Coffee").
                - description: A detailed, SEO-friendly description highlighting the lighting, mood, and available space for product placement.
                - tags: A comma-separated string of 5-10 relevant keywords (e.g., "desk, wood, coffee, cozy, morning, workspace").
                - slug: A URL-friendly slug based on the title (e.g., "cozy-wooden-desk-scene").
                - custom_prompt: A short instruction for an AI to place a product into this scene (e.g., "Place the product on the center of the wooden desk, matching the warm morning lighting and soft shadows.").
                
                Do not include markdown formatting like \`\`\`json. Just the raw JSON string.
            `;
        } else {
            prompt = `
                Analyze this product mockup image and generate SEO-optimized details for it.
                ${hintContext}
                ${keywordContext}
                Return ONLY a JSON object with the following fields:
                - title: A catchy, descriptive title (e.g., "Minimalist White Hoodie Mockup on Hanger").
                - description: A detailed, SEO-friendly description highlighting the setting, lighting, and vibe.
                - tags: A comma-separated string of 5-10 relevant keywords (e.g., "hoodie, streetwear, hanger, white, minimalist").
                - slug: A URL-friendly slug based on the title (e.g., "minimalist-white-hoodie-hanger").
                - custom_prompt: A short instruction for an AI to place a design on this product (e.g., "Place the design on the center chest area, maintaining the fabric wrinkles and lighting.").
                
                Do not include markdown formatting like \`\`\`json. Just the raw JSON string.
            `;
        }

        const result = await model.generateContent([
            prompt,
            imagePart // Pass the part object directly
        ]);

        const text = result.response.text();

        // Clean up markdown if present
        const cleanText = text.replace(/```json/g, '').replace(/```/g, '').trim();

        return JSON.parse(cleanText);

    } catch (error: any) {
        console.error("Gemini Analysis Error:", error);
        throw new Error("Failed to analyze image: " + error.message);
    }
};

export const generateScene = async (
    baseImageUrl: string,
    prompt: string,
    styleReferenceUrls: string[] = [],
    aspectRatio: string = '1:1',
    imageSize: string = '1K'
) => {
    if (!apiKey) {
        throw new Error("Missing GEMINI_API_KEY in environment variables.");
    }

    try {
        console.log(`Calling Copié-Collé (Gemini Scene Generation) with ${styleReferenceUrls.length} style refs, ratio ${aspectRatio}, size ${imageSize}...`);

        const genAI = new GoogleGenerativeAI(apiKey);
        const model = genAI.getGenerativeModel({
            model: modelId,
            generationConfig: {
                responseModalities: ["IMAGE"],
                imageConfig: {
                    aspectRatio: aspectRatio,
                    imageSize: imageSize
                }
            } as any
        });

        const baseImagePart = await getImagePart(baseImageUrl);

        const styleParts = await Promise.all(
            styleReferenceUrls.map(url => getImagePart(url))
        );

        // Construct Prompt
        const fullPrompt = `
            Take this blank product image (first image) and place it into a professional, photorealistic scene.
            ${prompt}
            ${styleParts.length > 0 ? 'Use the provided additional images as STYLE REFERENCES for the lighting, mood, and composition.' : ''}
            Important: Keep the product itself (shape, material) exactly as is, just change the background and lighting to match the scene.
            Ensure high quality, detailed texture, and realistic lighting.
        `;

        console.log("Sending scene generation request...");
        const result = await model.generateContent([
            fullPrompt,
            baseImagePart,
            ...styleParts
        ]);
        const apiResponse = await result.response;

        const parts = apiResponse.candidates?.[0]?.content?.parts;
        const imagePart = parts?.find((part: any) => part.inlineData);

        if (!imagePart || !imagePart.inlineData) {
            throw new Error("No image generated by the model.");
        }

        const base64Image = imagePart.inlineData.data;
        const resMimeType = imagePart.inlineData.mimeType || 'image/png';

        return {
            success: true,
            mockUrl: `data:${resMimeType};base64,${base64Image}`
        };

    } catch (error: any) {
        console.error("Gemini Scene Gen Error:", error);
        return {
            success: false,
            error: error.message || "Unknown error"
        };
    }
};

export const generateProductPlacement = async (
    sceneImageUrl: string,
    mainProductImageUrl: string,
    referenceProductImageUrls: string[],
    prompt: string,
    aspectRatio: string = '1:1',
    imageSize: string = '1K'
) => {
    if (!apiKey) {
        throw new Error("Missing GEMINI_API_KEY in environment variables.");
    }

    try {
        console.log(`Calling Copié-Collé (Product Placement) with Aspect Ratio: ${aspectRatio} and Size: ${imageSize}...`);

        const genAI = new GoogleGenerativeAI(apiKey);
        const model = genAI.getGenerativeModel({
            model: modelId,
            generationConfig: {
                responseModalities: ["TEXT", "IMAGE"],
                imageConfig: {
                    aspectRatio: aspectRatio,
                    imageSize: imageSize
                }
            } as any
        });

        console.log("Fetching image assets...");

        // Fetch Scene and Main Product
        const [sceneImagePart, mainProductPart] = await Promise.all([
            getImagePart(sceneImageUrl),
            getImagePart(mainProductImageUrl)
        ]);

        // Fetch Reference Images
        const referenceParts = await Promise.all(
            referenceProductImageUrls.map(url => getImagePart(url))
        );

        // Construct Prompt for Product Placement
        const fullPrompt = `
            Generate a photorealistic product photography shot.
            ${prompt}
            Task: REPLACE the sample product in the provided scene (first image) with the new product provided (second image and references).
            CRITICAL INSTRUCTIONS:
            1. IDENTIFY the sample product/object currently in the scene (first image).
            2. REPLACE that object completely with the new product from the second image.
            3. MATCH the exact position, scale, perspective, and lighting of the original sample product.
            4. PRESERVE the new product's identity (shape, label, colors, details) exactly as shown in the reference images.
            5. The background scene must remain unchanged, only the product is swapped.
            6. Ensure realistic shadows and reflections that match the scene's lighting environment.
        `;

        console.log(`Sending request to model with ${referenceParts.length} reference images...`);

        const result = await model.generateContent([
            fullPrompt,
            sceneImagePart,
            mainProductPart,
            ...referenceParts
        ]);
        const response = await result.response;

        console.log("Model response candidates:", response.candidates);

        const parts = response.candidates?.[0]?.content?.parts;
        const imagePart = parts?.find((part: any) => part.inlineData);

        if (!imagePart || !imagePart.inlineData) {
            const textPart = parts?.find((part: any) => part.text);
            if (textPart) {
                console.warn("Model returned text instead of image:", textPart.text);
                throw new Error("Model returned text: " + textPart.text);
            }
            throw new Error("No image generated by the model.");
        }

        const base64Image = imagePart.inlineData.data;
        const mimeType = imagePart.inlineData.mimeType || 'image/png';

        return {
            success: true,
            mockUrl: `data:${mimeType};base64,${base64Image}`
        };

    } catch (error: any) {
        console.error("Gemini Product Placement Error:", error);
        return {
            success: false,
            error: error.message || "Unknown error"
        };
    }
};

export const refinePrompt = async (prompt: string) => {
    if (!apiKey) {
        throw new Error("Missing GEMINI_API_KEY in environment variables.");
    }

    try {
        const genAI = new GoogleGenerativeAI(apiKey);
        // Use a text-optimized model for this
        const model = genAI.getGenerativeModel({ model: "gemini-3-pro-preview" });

        const systemPrompt = `
            You are an expert photographer and prompt engineer for AI image generation.
            Your task is to take a simple user description and enhance it into a detailed, photorealistic scene description for product photography.
            
            Focus on:
            - Lighting (e.g., cinematic, soft, golden hour, studio)
            - Texture and Materials (e.g., marble, wood, fabric)
            - Mood and Atmosphere
            - Composition (e.g., depth of field, bokeh)
            
            Constraints:
            - Keep the product itself generic (refer to it as "the product") as it will be inserted later.
            - Keep the description under 50 words.
            - Return ONLY the enhanced prompt text. Do not add quotes or explanations.
            
            User Input: "${prompt}"
        `;

        const result = await model.generateContent(systemPrompt);
        const response = await result.response;
        return response.text().trim();

    } catch (error: any) {
        console.error("Gemini Prompt Refinement Error:", error);
        throw new Error("Failed to refine prompt: " + error.message);
    }
};

/**
 * Multi-turn mockup generation using Gemini 3 Pro Image Preview.
 * Allows users to provide custom instructions and refine results iteratively.
 * 
 * @param baseImageUrl - The blank product mockup image
 * @param designImageUrl - The raw design image to be placed
 * @param instruction - User's custom instruction (e.g., "make it fit in the frame")
 * @param previousResultUrl - Previous generated image URL (for refinement)
 * @param history - Conversation history from previous turns
 * @param aspectRatio - Output aspect ratio
 * @param imageSize - Output size (1K, 2K)
 */
export const generateMockupMultiTurn = async (
    baseImageUrl: string | null,
    designImageUrl: string | null,
    instruction: string,
    previousResultUrl?: string,
    history?: any[],
    aspectRatio: string = '1:1',
    imageSize: string = '1K'
) => {
    if (!apiKey) {
        throw new Error("Missing GEMINI_API_KEY in environment variables.");
    }

    try {
        console.log(`[Multi-Turn] Starting with instruction: "${instruction}", history length: ${history?.length || 0}`);

        const genAI = new GoogleGenerativeAI(apiKey);
        const model = genAI.getGenerativeModel({
            model: modelId,
            generationConfig: {
                // Gemini 3 Pro Image requires both TEXT and IMAGE modalities
                responseModalities: ["TEXT", "IMAGE"],
                imageConfig: {
                    aspectRatio: aspectRatio,
                    imageSize: imageSize
                }
            } as any
        });

        // Sanitize history to remove inlineData from model responses
        // This prevents the [GoogleGenerativeAI Error]: Content with role 'model' can't contain 'inlineData' part
        const sanitizedHistory = history?.map(item => {
            if (item.role === 'model') {
                const newParts = item.parts.filter((part: any) => !part.inlineData);
                // If we stripped everything (e.g. it was just an image), add placeholder text
                // so the history item remains valid (must have at least 1 part).
                if (newParts.length === 0) {
                    newParts.push({ text: "[Image Generated]" });
                }
                return {
                    role: item.role,
                    parts: newParts
                };
            }
            return item;
        }) || [];

        // Start a chat session with history
        const chat = model.startChat({
            history: sanitizedHistory
        });

        // Build the message parts
        const messageParts: any[] = [];

        // If this is a refinement (we have a previous result), use different prompting
        if (previousResultUrl) {
            const previousPart = await getImagePart(previousResultUrl);
            messageParts.push(
                `This is my previous generated mockup. Please refine it based on this instruction: ${instruction}. Keep the overall composition but apply the requested changes. Generate a new image.`,
                previousPart
            );
        } else {
            // First generation - send base mockup + design image separately
            if (!baseImageUrl || !designImageUrl) {
                throw new Error("Base image and Design image are required for first generation");
            }

            const basePart = await getImagePart(baseImageUrl);
            const designPart = await getImagePart(designImageUrl);

            messageParts.push(
                `Task: Create a photorealistic product mockup.
                Instruction: ${instruction}.
                Image 1: The blank product (Base Mockup).
                Image 2: The design/logo to place.
                
                Action: Place the design (Image 2) onto the product (Image 1) according to the user's instruction.
                - Preserve the exact colors and details of the design.
                - Apply it realistically to the product surface (curvature, texture, fabric wrinkles, lighting, shadows).
                - Do NOT change the product background or shape, just apply the design.
                Generate the final composite image.`,
                basePart,
                designPart
            );
        }

        console.log("[Multi-Turn] Sending message to chat...");
        const result = await chat.sendMessage(messageParts);
        const response = await result.response;

        // Extract image from response
        const parts = response.candidates?.[0]?.content?.parts;
        const imagePart = parts?.find((part: any) => part.inlineData);
        const textPart = parts?.find((part: any) => part.text);

        if (!imagePart?.inlineData) {
            const errorText = textPart?.text || "No image generated";
            console.warn("[Multi-Turn] No image returned:", errorText);
            throw new Error(errorText);
        }

        const base64Image = imagePart.inlineData.data;
        const mimeType = imagePart.inlineData.mimeType || 'image/png';

        // Get updated history for next turn
        const updatedHistory = await chat.getHistory();

        console.log(`[Multi-Turn] Success! Updated history length: ${updatedHistory.length}`);

        return {
            success: true,
            mockUrl: `data:${mimeType};base64,${base64Image}`,
            modelResponse: textPart?.text || null,
            history: updatedHistory
        };

    } catch (error: any) {
        console.error("[Multi-Turn] Error:", error);
        return {
            success: false,
            error: error.message || "Unknown error",
            history: history || []
        };
    }
};

/**
 * Brainstorms multiple unique SEO angles/strategies based on a seed keyword.
 * Used for Programmatic SEO (pSEO) batch generation.
 */
export const generateSeoStrategy = async (seedKeyword: string, count: number = 5, guidance?: string) => {
    if (!apiKey) {
        throw new Error("Missing GEMINI_API_KEY in environment variables.");
    }

    try {
        const genAI = new GoogleGenerativeAI(apiKey);
        const model = genAI.getGenerativeModel({ model: "gemini-3-pro-preview" });

        const prompt = `
            You are an expert SEO Strategist and Creative Director.
            Target Product/Topic: "${seedKeyword}".
            ${guidance ? `\nUSER GUIDANCE / CREATIVE DIRECTION: "${guidance}"\n(Strictly follow this direction for all generated angles)\n` : ''}
            
            Task: Generate ${count} DISTINCT and UNIQUE visual/SEO angles for this product to target different long-tail search intents.
            Avoid generic repetition. Think about:
            1. Different Environments (e.g., Urban, Nature, Studio, Home)
            2. Different Visual Styles (e.g., Minimalist, Vintage, High-Contrast, Pastel)
            3. Different Target Audiences (e.g., Students, Professionals, Hikers)
            
            Return ONLY a JSON array with ${count} objects. Each object must have:
            - title: A catchy, SEO-friendly page title (e.g., "Vintage Aesthetic ${seedKeyword} Mockup").
            - keyword: The main focus keyword for this angle (e.g., "vintage ${seedKeyword}").
            - image_prompt: A precise instruction for an AI image generator to place the design on the product in this specific context/style. (e.g., "Place the design on the hoodie worn by a model in a cozy coffee shop setting, soft warm lighting.").
            
            Example Format:
            [
              { "title": "...", "keyword": "...", "image_prompt": "..." },
              ...
            ]
            
            Do not include markdown formatting like \`\`\`json. Just the raw JSON string.
        `;

        const result = await model.generateContent(prompt);
        const text = result.response.text();

        // Clean up markdown if present
        const cleanText = text.replace(/```json/g, '').replace(/```/g, '').trim();

        return JSON.parse(cleanText);

    } catch (error: any) {
        console.error("Gemini Strategy Generation Error:", error);
        throw new Error("Failed to generate SEO strategy: " + error.message);
    }
};
